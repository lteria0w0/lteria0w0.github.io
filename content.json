{"posts":[{"title":"docker快速入门","text":"docker安装 为什么使用docker？都什么年代了，还在使用传统容器？安装环境是什么？centos7.4官方文档？Home - Docker 详情 快速查看自己的系统版本 cat /etc/redhat-release 安装gcc相关指令 yum -y install gccyum -y install gcc-c++ 安装软件包 yum install -y yum-utils 设置stable镜像(相较于官方镜像，国内的镜像更加稳定) yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新软件包索引 yum makecache fast 安装docker ce yum -y install docker-ce docker-ce-cli containerd.io 到此时，安装已经完成了，现在需要进行启动以及测试是否安装成功 启动docker systemctl start docker 检查版本 docker version 传统的运行hello world镜像 docker run hello-world 卸载指令 systemctl stop dockeryum remove docker-ce docker-ce-cli containerd.iorm -rf /var/lib/dockerrm -rf /var/lib/containerd 额外步骤，配置阿里云镜像加速—注册一个账号直接粘贴脚本重启docker systemctl daemon-reloadsystemctl restart docker docker常用指令1. 帮助命令启动docker systemctl start docker 停止docker systemctl stop docker 重启docker systemctl restart docker 查看docker状态 systemctl status docker 设置开机启动 systemctl enable docker 帮助文档 docker –help 具体指令帮助文档 docker 具体指令 –help 2. 镜像命令列出所有镜像 docker images 查找ubuntu这个镜像 docker search ubuntu 拉取mysql5.0.8这个镜像 docker pull mysql:5.0.8 查看镜像信息 docker system df 强制删除mysql这个镜像 docker rmi -f mysql 简单运行镜像指令(以交互模式，分配一个伪终端，命名为myubuntu，以/bin/bash为脚本运行ubuntu镜像) docker run -it –name=myubuntu ubuntu /bin/bash 3. 容器命令列出当前运行的所有容器 docker ps -a 退出容器（容器会停止，但不会删除） exit 容器id 启动已经停止的容器 docker start 容器id 重启容器 docker restart 容器ID 停止容器 docker stop 容器ID 强制停止容器 docker kill 容器ID 强制删除容器 docker rm -f 容器ID 查看容器日志 docker logs 容器ID 查看容器进程 docker top 容器ID 查看内部细节 docker inspect 容器ID 重新进入容器(exit退出容器后容器不会停止) docker exec -it 容器ID /bin/bash 将容器内文件拷贝到主机 docker cp 容器ID:容器内路径 目的主机路径 导出镜像 docker export 容器ID &gt; 文件名.tar 导入镜像 cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号 镜像的提交1. 直接提交到hub上 docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名] 2. 发布到阿里云上阿里云的具体流程：https://promotion.aliyun.com/ntms/act/kubernetes.html创建个人实例-创建命名空间-创建仓库-进入管理界面获得脚本-根据阿里云给予的指令提交 3. 发布私有云下载镜像文件 docker pull registry 运行私有库且映射主机于其5000端口 docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry –privileged=true registry 准备上传镜像 验证是否存在镜像 curl -XGET http://192.168.111.162:5000/v2/_catalog 将镜像名称改为符合规范的名称 docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2 修改配置文件 vim /etc/docker/daemon.json 添加如下json代码 1234{ &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;192.168.202.128:5000&quot;]} 推送到私有库 docker push 192.168.111.162:5000/zzyyubuntu:1.2 再使用crul验证 数据卷 为何使用数据卷?通过将主机文件和容器文件进行映射，可以进行文件共享互通且进行数据的持久化 添加数据卷并为其赋予权限 docker run -it –privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名 继承父数据卷特性 docker run -it –privileged=true –volumes-from 父类 –name u2 ubuntu","link":"/2022/08/13/docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"设计模式","text":"设计原则 提取并封装变化之处。 针对接口编程，不是针对实现编程。 多用组合，少用继承。 为了交互对象之间的松耦合设计而努力 对拓展开放，对修改关闭 要依赖抽象，不要依赖具体类 最少知识原则 好莱坞原则：让别人调用自己 一个类应该只有一个引起变化的原因 详情 策略模式定义：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户； 主类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package fans.hitagi.duck; /** * 引入设计原则：1.2.3 * 使用设计模式：策略模式 * 通过委托行为类的方式来完成逻辑的实现 * 通过set get方法动态获取行为类对象 */ public class Duck { public FlyBehavior fly; public QuackBehavior quack; public Duck(){ fly = new FlyBehavior() { @Override public void fly() { System.out.println(&quot;Duck can quack&quot;); } }; quack = new QuackBehavior() { @Override public void quack() { System.out.println(&quot;Duck can fly&quot;); } }; } //动态获取行为类对象 public void setFly(FlyBehavior fly) { this.fly = fly; } public void setQuack(QuackBehavior quack) { this.quack = quack; } public void doFly(){ fly.fly(); } public void doQuack(){ quack.quack(); } public static void main(String[] args) { Duck duck = new Duck(); duck.doQuack(); } } 行为类的抽象接口 123456789101112package fans.hitagi.duck; public interface FlyBehavior { void fly(); }//----------------------package fans.hitagi.duck; public interface QuackBehavior { void quack(); } 代理模式定义：为另一个对象提供一个替身或者占位符以控制这个对象的访问 抽象类 12345678package fans.hitagi.net; /** * 抽象类，使得可以对代理类使用服务类同样的操作 */ public interface Suject { void request(); } 代理对象 1234567891011121314151617181920212223package fans.hitagi.net; import fans.hitagi.weather.Subject; /** * 引入设计原则：无 * 使用设计模式：代理模式 * 通过代理对象访问服务对象，可以增加安全性，强化方法等作用 */ public class MachineProxy implements Suject { Machine machine = new Machine(); public MachineProxy(Machine machine) { this.machine = machine; } @Override public void request() { machine.request(); System.out.println(&quot;do MachineProxy&quot;); } } 服务对象 123456789101112package fans.hitagi.net; /** * 服务对象 */ public class Machine implements Suject{ @Override public void request() { System.out.println(&quot;do Machine&quot;); } } 单例模式定义：确保类只有一个实例，并提供一个全局访问点 主类 12345678910111213141516171819202122package fans.hitagi.singlleton; /** * 引入设计原则：无 * 使用设计模式：单例模式 * 通过私有化构造方法，来达到仅有一个实例的方式 * 多线程需要其他处理方法 */ public class Singleton { private static Singleton uniqueInstance; private Singleton(){ } public static Singleton getInstance90(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 迭代器模式定义： 主类 1234567891011121314151617181920212223242526272829303132package fans.hitagi.dinner; /** * 引入设计原则：9 * 使用设计模式：迭代器模式 * 通过实现迭代器接口，类中集合类型对象的访问被封装于类中，保证访问的统一 */ public class DinerMenuIterator implements Iteator{ MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items){ this.items = items; } @Override public boolean hasNext() { if(position &gt;= this.items.length || items[position] == null){ return false; }else { return true; } } @Override public Object next() { MenuItem menuItem = items[position]; position += 1; return menuItem; } } 迭代器接口 123456789package fans.hitagi.dinner; /** * 迭代器接口 */ public interface Iteator{ boolean hasNext(); Object next(); } 元素类 1234567package fans.hitagi.dinner; /** * 元素类 */ public class MenuItem { } 工厂模式定义： 工厂：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类中 抽象工厂：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 工厂抽象类 1234567891011121314151617package fans.hitagi.pizza; /** * 引入设计原则：6 * 使用设计模式：抽象工厂 * 工厂抽象类，定义了一系列产品族的抽象方法 * 子类只需要根据具体情况返回产品族的具体实现 * 普通类-&gt;简单工厂：提供了一个自动生产对象的工厂 * 简单工厂-&gt;工厂方法：将工厂抽象，不同工厂有不同实现 * 工厂方法-&gt;抽象工厂：将产品定义为产品组，抽象工厂指定产品族，实际工厂具体实现产品组的实例类 */ public interface PizzaIngredientFectory { Dough createDough(); Sauce createSauce(); Cheese createCheese(); Clams createClams(); } 产品家族抽象类 12345678910111213package fans.hitagi.pizza; public interface Cheese { }public interface Clams { }public interface Dough { }public interface Sauce { } 产品家族具体实现 12345678910111213141516171819202122package fans.hitagi.pizza; public class FreshClams implements Clams { }public class FrozenClams implements Clams{ }public class MarinaraSouce implements Sauce{ }public class PlumTomatoSauce implements Sauce{ }public class MozzarellaCheese implements Cheese{ }public class ReggianoCheese implements Cheese{ }public class ThickcrusDough implements Dough{ }public class TinCrustDough implements Dough{ } 工厂具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445package fans.hitagi.pizza; public class NYPizzaIngredientFactory implements PizzaIngredientFectory{ @Override public Dough createDough() { return new ThickcrusDough(); } @Override public Sauce createSauce() { return new PlumTomatoSauce(); } @Override public Cheese createCheese() { return new MozzarellaCheese(); } @Override public Clams createClams() { return new FrozenClams(); } }public class ChicagoPizzaIngredientFactory implements PizzaIngredientFectory{ @Override public Dough createDough() { return new TinCrustDough(); } @Override public Sauce createSauce() { return new MarinaraSouce(); } @Override public Cheese createCheese() { return new ReggianoCheese(); } @Override public Clams createClams() { return new FreshClams(); } } 观察者模式定义：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖着都会收到通知并自动更新 主类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package fans.hitagi.weather; import java.util.ArrayList; /** * 引入设计原则：4 * 使用设计模式：观察者模式 * 通过接口抽象了观察者的两个行为和主题的行为 */ public class WeatherDate implements Subject{ private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherDate() { this.observers = new ArrayList&lt;Observer&gt;(); } @Override public void reigisterObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { int i = observers.indexOf(observer); if (i &gt;= 0){ observers.remove(i); } } @Override public void notifyObserver() { for (Observer observer:observers) { observer.update(temperature,humidity,pressure); } } public void measurementsChanged(){ notifyObserver(); } public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); } } 观察者类 1234567891011121314151617181920212223242526272829package fans.hitagi.weather; /** * 通过实现两个行为来进行数据修改和展示 */ public class CurrentConditionsDisplay implements Observer,DisplayElemeent{ private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) { this.weatherData = weatherData; weatherData.reigisterObserver(this); } @Override public void display() { System.out.println(&quot;temperature: &quot;+ temperature + &quot; humidity&quot; + humidity); } @Override public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; display(); } } 行为接口 123456789101112131415161718192021222324252627package fans.hitagi.weather; /** * 观察者实现该行为 * 观察者在被主题调用修改行为后自动调用该行为 * 通过该行为来进行数据的展示 */ public interface DisplayElemeent { void display(); }/** * 观察者实现该行为 * 主题通过调用该行为来通知观察者数据的改变 */ public interface Observer { void update(float temperature,float humidity,float pressure); }/** * 主题通过该行为注册删除观察者 * 观察者调用主题的行为来进行注册 * 主题改变后调用通知行为通知观察者 */ public interface Subject { void reigisterObserver(Observer observer); void removeObserver(Observer observer); void notifyObserver(); } 命令模式定义：将请求封装成对象，以便使用不同的请求，队列或操作日志来参数化其他对象。命令模式也可以在支持撤销的操作。 控制类 12345678910111213141516171819202122package fans.hitagi.control; /** * 引入设计原则；无 * 使用设计模式：命令模式 * 主类绑定并使用命令对象，使得命令方式统一，便于管理 */ public class RemoteControl { Command[] commands; public RemoteControl() { this.commands = new Command[2]; } public void setCommands(int slot,Command command){ this.commands[slot] = command; } public void doCommand(int slot){ this.commands[slot].excute(); } } 命令抽象接口 12345678package fans.hitagi.control; /** * 命令封装接口，所有命令都是用excute执行，具体逻辑具体类来实现 */ public interface Command { void excute(); } 模板方法定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 模板抽象类 123456789101112131415161718192021222324252627282930313233343536package fans.hitagi.tea; /** * 引入设计原则：8 * 使用设计模式：模板方法 * 模板抽象类的抽象方法通过将方法的调用顺序固定，而方法则将需要的延迟到子类 * 通过一个方法的返回值来确定另一个方法的调用，而这个返回值则根据具体实现来决定，以此构建了一个钩子 * 非抽象方法子类选择重写，抽象方法子类必须重写 */ public abstract class Caffeinebeverage { final void prepareRecipe(){ bioWate(); brew(); pouInCup(); if(customerwantsCondiments()){ addCondiments(); } } abstract void brew(); abstract void addCondiments(); void pouInCup(){ } void bioWate(){ } boolean customerwantsCondiments(){ return true; } } 实现类 1234567891011121314151617181920212223242526/** * 实现类 */ public class Caffee extends Caffeinebeverage{ @Override void brew() { } @Override void addCondiments() { } }public class Tea extends Caffeinebeverage{ @Override void brew() { } @Override void addCondiments() { } } 适配器模式定义；将一个类的接口，转换成客户端的另一个接口。适配器让原本的接口不兼容的类可以合作无间 适配器类 1234567891011121314151617181920212223242526package fans.hitagi.durkey; /** * 引入设计原则：无 * 使用设计模式：适配器模式--对象适配器(类适配器需要多重继承) * 通过继承需要适配的类，然后再在类中引用一个需要被适配的对象，这样就可以访问适配类的时候自动访问被适配类的方法 */ public class DurkeyAdapter extends Duck{ Durkey durkey; public DurkeyAdapter(Durkey durkey) { this.durkey = durkey; } @Override void quack() { this.durkey.gobble(); } @Override void fly() { this.durkey.fly(); } } 适配与被适配类 1234567891011121314151617package fans.hitagi.durkey; /** * 适配类 */ public abstract class Duck { abstract void quack(); abstract void fly(); }/** * 被适配类 */ public abstract class Durkey { abstract void gobble(); abstract void fly(); } 外观模式定义：定义了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层结构，让子系统更容易使用。 控制类 123456789101112131415161718192021222324package fans.hitagi.tv; /** * 引入设计原则：7 * 使用设计模式：外观模式 * 通过使用外观对象来对复杂的系统类进行调用，客户仅需访问外观对象的固定方法即可 * 类似于命令模式，都是封装统一 */ public class TVControl implements Facde{ Channel channel; Volume volume; public TVControl(Channel channel, Volume volume) { this.channel = channel; this.volume = volume; } @Override public void toDo() { channel.setValue(10); volume.setRange(10); } } 控制抽象接口 12345678package fans.hitagi.tv; /** * 控制类抽象接口 */ public interface Facde { void toDo(); } 子系统类 12345678910111213141516171819202122232425262728293031package fans.hitagi.tv; /** * 子系统类 */ public class Channel { int value = 0; public int getValue() { return value; } public void setValue(int value) { this.value = value; } }/** * 子系统类 */ public class Volume { int range = 0; public int getRange() { return range; } public void setRange(int range) { this.range = range; } } 装饰模式定义：动态的将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的方案 核心类 12345678910111213141516/** * 引入设计原则：5 * 使用设计模式：装饰者模式 * 核心类，保证了每次装饰其本质不变(父类型指向子对象) * 通过将饮料分为材料和基础饮料和添加材料两种子类，划分了其逻辑功能。 * java的IO流正是使用了这种设计模式 */ public abstract class Beverage { public String description = &quot;Unknown Beverage &quot;; public String getDescription(){ return this.description; } public abstract double cost(); } 材料抽象类 12345678910package fans.hitagi.coffee; /** * 材料抽象类，保证了材料都必须继承获取描述的动作 * 由其封装饮料类，但本质也是饮料。 * 保证了即使拓展也不需要修改类 */ public abstract class CondimentDecorator extends Beverage{ public abstract String getDescription(); } 材料实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package fans.hitagi.coffee; /** * 牛奶类 */ public class Milk extends CondimentDecorator{ Beverage beverage; public Milk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .20+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;， Milk&quot;; } }/** * 摩卡类 */ public class Mocha extends CondimentDecorator{ Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .18+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;, Mocha&quot;; } } 基础饮品类 12345678910111213141516171819202122232425262728293031323334package fans.hitagi.coffee; /** * 饮料类 */ public class HouseBlend extends Beverage{ public HouseBlend() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } }package fans.hitagi.coffee; /** * 饮料类 */ public class Espresso extends Beverage{ public Espresso() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } } 状态模式定义：动态的将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的方案 核心类 12345678910111213141516/** * 引入设计原则：5 * 使用设计模式：装饰者模式 * 核心类，保证了每次装饰其本质不变(父类型指向子对象) * 通过将饮料分为材料和基础饮料和添加材料两种子类，划分了其逻辑功能。 * java的IO流正是使用了这种设计模式 */ public abstract class Beverage { public String description = &quot;Unknown Beverage &quot;; public String getDescription(){ return this.description; } public abstract double cost(); } 材料抽象类 12345678910package fans.hitagi.coffee; /** * 材料抽象类，保证了材料都必须继承获取描述的动作 * 由其封装饮料类，但本质也是饮料。 * 保证了即使拓展也不需要修改类 */ public abstract class CondimentDecorator extends Beverage{ public abstract String getDescription(); } 材料实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package fans.hitagi.coffee; /** * 牛奶类 */ public class Milk extends CondimentDecorator{ Beverage beverage; public Milk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .20+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;， Milk&quot;; } }/** * 摩卡类 */ public class Mocha extends CondimentDecorator{ Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .18+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;, Mocha&quot;; } } 基础饮品类 12345678910111213141516171819202122232425262728293031323334package fans.hitagi.coffee; /** * 饮料类 */ public class HouseBlend extends Beverage{ public HouseBlend() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } }package fans.hitagi.coffee; /** * 饮料类 */ public class Espresso extends Beverage{ public Espresso() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } } 组合模式定义：允许你将对象组合成树形结构来表现整体/部分的层次结构。组合能让客户以一致的方式处理个别对象一级对象组合 菜单抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142package fans.hitagi.menu; /** * 引入设计原则：无 * 使用设计模式：组合模式 * 抽象了菜单，将所有可能实现的方法进行异常抛出，防止使用未被重写的方法 * 统一了菜单和组合菜单---多态 */ public abstract class MenuComponent { public void add(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } public void remove(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } public MenuComponent getChild(int i){ throw new UnsupportedOperationException(); } public String getName(){ throw new UnsupportedOperationException(); } public String getDescription(){ throw new UnsupportedOperationException(); } public double getPrice(){ throw new UnsupportedOperationException(); } public boolean isVegetarian(){ throw new UnsupportedOperationException(); } public void print(){ throw new UnsupportedOperationException(); } } 普通菜单类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package fans.hitagi.menu; /** * 普通菜单，仅仅只能添加材料 */ public class menuiItem extends MenuComponent{ String name; String description; boolean vegetarian; double price; public menuiItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } @Override public String getName() { return name; } @Override public String getDescription() { return description; } @Override public boolean isVegetarian() { return vegetarian; } @Override public double getPrice() { return price; } public void print(){ System.out.println(&quot; &quot; + getName()); if(isVegetarian()){ System.out.println(&quot;(v)&quot;); } System.out.println(&quot;, &quot; + getPrice()); System.out.println(&quot; ----&quot; + getDescription()); } } 组合菜单类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package fans.hitagi.menu; import fans.hitagi.dinner.Iteator; import java.util.ArrayList; /** * 组合菜单 * 可以添加普通菜单和材料 * 和菜单同样被视为菜单的抽象 * 多实现了添加和删除方法 * print方法的不同区分了两种菜单在输出的时候的不同处理方式，但又都是菜单的抽象，方法相同，因此向访问者的访问方式进行了统一 * print方法使用了递归的方式，知道成为普通菜单位置，自顶向下的逐个访问 */ public class menu extends MenuComponent{ ArrayList menus = new ArrayList(); String name; String descritption; public menu(String name, String descritption) { this.name = name; this.descritption = descritption; } @Override public void add(MenuComponent menuComponent) { super.add(menuComponent); } @Override public void remove(MenuComponent menuComponent) { super.remove(menuComponent); } @Override public MenuComponent getChild(int i) { return super.getChild(i); } @Override public String getName() { return this.name; } @Override public String getDescription() { return this.descritption; } public void print(){ System.out.println(&quot;\\n&quot; + getName()); System.out.println(&quot;, &quot; + getDescription()); System.out.println(&quot;----------------------&quot;); Iteator iteator = (Iteator) menus.iterator(); while (iteator.hasNext()){ MenuComponent next = (MenuComponent) iteator.next(); next.print(); } } }","link":"/2022/08/10/DesignPatterns/"},{"title":"mysql简单操作","text":"详情 查询语句1. 基础查询这是基础查询的完整命令 123456789101112131415SELECT //需要列出的字段 users.uname FROM //需要查询的列表 users WHERE //初次筛选条件（不能使用聚合函数） uid = &quot;1&quot;GROUP BY //分组 uid HAVING //分组后筛选条件（可以使用聚合函数） uid IS NOT NULL ORDER BY //排序条件 uidDESC //排序方式为降序LIMIT //取前几个数据 1 2. 连接查询取笛卡尔积 123456SELECT *from students,classesWHERE students.cid = classes.cid 自然连接（自动匹配连接字段，但字段名要相同） 12345SELECT * FROM students NATURAL JOIN classes 内连接（仅显示符合条件） 123456SELECT * FROM students INNER JOIN classes ON cid 外连接（外连接方向符合条件即可） 123456SELECT * FROM students RIGHT JOIN JOIN classes ON cid 列表操作1. 列表的更新创建语句 123456create table teachers( `tid` varchar(100) not null COMMENT &quot;教师id&quot;, `tname` varchar(100) unique not null COMMENT &quot;教师姓名&quot;, `cid` int(100) UNSIGNED not null COMMENT &quot;课程id&quot;, primary key(tid)) 更改语句 1ALTER TABLE teachers ADD phone_number VARCHAR ( 200 ) DEFAULT &quot;11111111111&quot; COMMENT &quot;电话号码&quot; 删除语句 1drop table teachers 2. 数据的更新插入数据 1234insert into teachers(tid,tname,cid,phone_number)values(&quot;1&quot;,&quot;张三&quot;,10,&quot;15220398751&quot;),(&quot;2&quot;,&quot;李四&quot;,13,&quot;12648975368&quot;) 删除数据 12delete from teacherswhere tid = &quot;1&quot; 更新数据 123update teachersset tname = &quot;王五&quot;where tid = &quot;2&quot; 视图操作1. 创建视图123create view myview asselect * from teachers 2. 查看视图12select * from myview 3. 删除视图1drop view myview","link":"/2022/08/18/mysql%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"设计模式笔记","slug":"设计模式笔记","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"}],"categories":[],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}