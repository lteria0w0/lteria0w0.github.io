{"posts":[{"title":"C#基础","text":"C#特点 C#模块的划分是通过命名空间的，因此导入非同一个命名空间的类需要手动引入通过dotnet指令开始运行程序Main函数大小写需要注意作用域是块作用域try语句同java运算符同大多数编程语言同java，var关键字可以简化代码字符串与数字的转化使用Convert.ToInt32(x)，int.Parse()用有垃圾分配机制，简化了内存分配引用数据类型和值类型传参时被修改方式不同字符串格式化输出可以使用{0} 充当占位符 详情 实例简单的hello world 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;namespace HellowWorld{ class Test1 { static void Main(String[] args) { const int AK = 10; String x = &quot;1&quot;; String y = &quot;2&quot;; Console.WriteLine(&quot;Hello, World! AK:&quot; + AK); int r = Convert.ToInt32(x) + Convert.ToInt32(y); Console.WriteLine(&quot;r = {0}&quot;,r); try { } catch (System.Exception) { throw; } } }} 对象的创建与使用 123456789101112131415161718192021222324252627namespace People{ class Person { public String name ; public int age; public void Introduce() { Console.WriteLine(&quot;My name is {0},My age is {1}&quot;,name,age); } }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;using People; namespace HellowWorld{ class Test2 { static void Main(String[] args) { int[] a = {1,2,3}; int[] b = a; b[1] = 10; Console.WriteLine(a[1]); Person jnason = new Person(); jnason.name = &quot;jnason&quot;; jnason.age = 25; jnason.Introduce(); Person jack = new Person(){name = &quot;jack&quot;,age = 19}; jack.Introduce(); } }} 流程控制 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using System; namespace HellowWorld{ class Test3 { static void Main(String[] args) { int x = 1; int y = 2; if(x &lt; y){ Console.WriteLine(&quot;x &lt; y&quot;); }else if(x == y){ Console.WriteLine(&quot;x = y&quot;); }else{ Console.WriteLine(&quot;x &gt; y&quot;); } switch(x){ case 1:Console.WriteLine(&quot;g&quot;);break; case 2:Console.WriteLine(&quot;gg&quot;);break; } for(int i = 1;i &lt; 10;i++){ Console.WriteLine(i); } int n = 0; while(n &lt; 19){ n ++; Console.WriteLine(n); } int[] arr = {1,2,3,4,5,6,7,8,9}; foreach(int a in arr){ Console.WriteLine(a); } } }} 常用api例如随机数 12345678910111213141516171819202122232425using System; namespace HellowRan{ class Test4 { static void Main(String[] args) { Random random = new Random(); Console.WriteLine(random.Next(1,2)); } }}","link":"/2022/08/20/C-%E5%9F%BA%E7%A1%80/"},{"title":"django快速搭建","text":"详情 1. 安装python勾选Add Pythonto Path来自动配置环境变量 使用命令查询安装完成的python版本 python 2. 安装Django安装命令（使用pypi官网）： pip install -i https://pypi.douban.com/simpleDjango 或者使用国内服务器 pip install -i https://pypi.tuna.tsinghua.edu.cn/Simple Django 查询当前django版本 python -m django –version 3. 安装pymysql安装命令 pip install -i https://pypi.couban.com/simplepymysql 查询安装情况 pip list 4. 安装IDE安装pycharm 5. 搭建项目命令行中输入 django-admin startproject myDjango 运行django python manage.py runserver 关闭django ctrl + c 添加应用 python manage.py startapp frist 6. controller的创建在模块views.py文件中创建函数 12def test(request): return HttpResponse(&quot;芝士测试&quot;) 在urls.py文件中将其与请求的url绑定 1234urlpatterns = [ path('admin/', admin.site.urls), path('test/', pl.views.test), ] 启动项目，并通过url进行访问 7. 模板的使用创建模板目录templates 配置文件setting.py中配置模板目录 123456789101112131415TEMPLATES = [ { 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, &quot;templates&quot;)], 'APP_DIRS': True, 'OPTIONS': { 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], }, }, ] 使用render函数直接渲染 12def he(request): return render(request,'hello.html') 8. 网页跳转为路由添加名称 1234urlpatterns = [ path('admin/', admin.site.urls), path('test/', pl.views.test,name=&quot;Test&quot;), ] 两种进行跳转的方式 12&lt;a href=&quot;/test&quot;&gt;跳转到about&lt;/a&gt; #硬编码&lt;a href=&quot;{% url 'Test' %}&quot;&gt;跳转到about&lt;/a&gt; #动态获取 9. 静态资源的配置创建静态资源文件夹static setting.py中配置静态资源目录 12STATIC_URL = '/static/' STATICFILES_DIRS=[os.path.join(BASE_DIR,'static')] 引用静态资源 1&lt;img src=&quot;/static/images/dz.jpg&quot;/&gt; 10. 正则表达式的使用创建函数 12def rfc(request): return HttpResponse(&quot;正则表达式的使用&quot;) 配置路径 1re_path('^rft/(?P&lt;data&gt;[A-Za-z]+)$', views.rfc), 11. 参数的传递创建函数 12def cs(request,data): return HttpResponse(&quot;传参&quot; + data) 配置路径 1path('cs/&lt;data&gt;', pl.views.cs),","link":"/2022/10/06/django%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"},{"title":"docker快速入门","text":"docker安装 为什么使用docker？都什么年代了，还在使用传统容器？安装环境是什么？centos7.4官方文档？Home - Docker 详情 快速查看自己的系统版本 cat /etc/redhat-release 安装gcc相关指令 yum -y install gccyum -y install gcc-c++ 安装软件包 yum install -y yum-utils 设置stable镜像(相较于官方镜像，国内的镜像更加稳定) yum-config-manager –add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 更新软件包索引 yum makecache fast 安装docker ce yum -y install docker-ce docker-ce-cli containerd.io 到此时，安装已经完成了，现在需要进行启动以及测试是否安装成功 启动docker systemctl start docker 检查版本 docker version 传统的运行hello world镜像 docker run hello-world 卸载指令 systemctl stop dockeryum remove docker-ce docker-ce-cli containerd.iorm -rf /var/lib/dockerrm -rf /var/lib/containerd 额外步骤，配置阿里云镜像加速—注册一个账号直接粘贴脚本重启docker systemctl daemon-reloadsystemctl restart docker docker常用指令1. 帮助命令启动docker systemctl start docker 停止docker systemctl stop docker 重启docker systemctl restart docker 查看docker状态 systemctl status docker 设置开机启动 systemctl enable docker 帮助文档 docker –help 具体指令帮助文档 docker 具体指令 –help 2. 镜像命令列出所有镜像 docker images 查找ubuntu这个镜像 docker search ubuntu 拉取mysql5.0.8这个镜像 docker pull mysql:5.0.8 查看镜像信息 docker system df 强制删除mysql这个镜像 docker rmi -f mysql 简单运行镜像指令(以交互模式，分配一个伪终端，命名为myubuntu，以/bin/bash为脚本运行ubuntu镜像) docker run -it –name=myubuntu ubuntu /bin/bash 3. 容器命令列出当前运行的所有容器 docker ps -a 退出容器（容器会停止，但不会删除） exit 容器id 启动已经停止的容器 docker start 容器id 重启容器 docker restart 容器ID 停止容器 docker stop 容器ID 强制停止容器 docker kill 容器ID 强制删除容器 docker rm -f 容器ID 查看容器日志 docker logs 容器ID 查看容器进程 docker top 容器ID 查看内部细节 docker inspect 容器ID 重新进入容器(exit退出容器后容器不会停止) docker exec -it 容器ID /bin/bash 将容器内文件拷贝到主机 docker cp 容器ID:容器内路径 目的主机路径 导出镜像 docker export 容器ID &gt; 文件名.tar 导入镜像 cat 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号 镜像的提交1. 直接提交到hub上 docker commit -m=”提交的描述信息” -a=”作者” 容器ID 要创建的目标镜像名:[标签名] 2. 发布到阿里云上阿里云的具体流程：https://promotion.aliyun.com/ntms/act/kubernetes.html创建个人实例-创建命名空间-创建仓库-进入管理界面获得脚本-根据阿里云给予的指令提交 3. 发布私有云下载镜像文件 docker pull registry 运行私有库且映射主机于其5000端口 docker run -d -p 5000:5000 -v /zzyyuse/myregistry/:/tmp/registry –privileged=true registry 准备上传镜像 验证是否存在镜像 curl -XGET http://192.168.111.162:5000/v2/_catalog 将镜像名称改为符合规范的名称 docker tag zzyyubuntu:1.2 192.168.111.162:5000/zzyyubuntu:1.2 修改配置文件 vim /etc/docker/daemon.json 添加如下json代码 1234{ &quot;registry-mirrors&quot;: [&quot;https://aa25jngu.mirror.aliyuncs.com&quot;], &quot;insecure-registries&quot;: [&quot;192.168.202.128:5000&quot;]} 推送到私有库 docker push 192.168.111.162:5000/zzyyubuntu:1.2 再使用crul验证 数据卷 为何使用数据卷?通过将主机文件和容器文件进行映射，可以进行文件共享互通且进行数据的持久化 添加数据卷并为其赋予权限 docker run -it –privileged=true -v /宿主机绝对路径目录:/容器内目录 镜像名 继承父数据卷特性 docker run -it –privileged=true –volumes-from 父类 –name u2 ubuntu","link":"/2022/08/13/docker%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"设计模式","text":"设计原则 提取并封装变化之处。 针对接口编程，不是针对实现编程。 多用组合，少用继承。 为了交互对象之间的松耦合设计而努力 对拓展开放，对修改关闭 要依赖抽象，不要依赖具体类 最少知识原则 好莱坞原则：让别人调用自己 一个类应该只有一个引起变化的原因 详情 策略模式定义：定义了算法族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化独立于使用算法的客户； 主类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package fans.hitagi.duck; /** * 引入设计原则：1.2.3 * 使用设计模式：策略模式 * 通过委托行为类的方式来完成逻辑的实现 * 通过set get方法动态获取行为类对象 */ public class Duck { public FlyBehavior fly; public QuackBehavior quack; public Duck(){ fly = new FlyBehavior() { @Override public void fly() { System.out.println(&quot;Duck can quack&quot;); } }; quack = new QuackBehavior() { @Override public void quack() { System.out.println(&quot;Duck can fly&quot;); } }; } //动态获取行为类对象 public void setFly(FlyBehavior fly) { this.fly = fly; } public void setQuack(QuackBehavior quack) { this.quack = quack; } public void doFly(){ fly.fly(); } public void doQuack(){ quack.quack(); } public static void main(String[] args) { Duck duck = new Duck(); duck.doQuack(); } } 行为类的抽象接口 123456789101112package fans.hitagi.duck; public interface FlyBehavior { void fly(); }//----------------------package fans.hitagi.duck; public interface QuackBehavior { void quack(); } 代理模式定义：为另一个对象提供一个替身或者占位符以控制这个对象的访问 抽象类 12345678package fans.hitagi.net; /** * 抽象类，使得可以对代理类使用服务类同样的操作 */ public interface Suject { void request(); } 代理对象 1234567891011121314151617181920212223package fans.hitagi.net; import fans.hitagi.weather.Subject; /** * 引入设计原则：无 * 使用设计模式：代理模式 * 通过代理对象访问服务对象，可以增加安全性，强化方法等作用 */ public class MachineProxy implements Suject { Machine machine = new Machine(); public MachineProxy(Machine machine) { this.machine = machine; } @Override public void request() { machine.request(); System.out.println(&quot;do MachineProxy&quot;); } } 服务对象 123456789101112package fans.hitagi.net; /** * 服务对象 */ public class Machine implements Suject{ @Override public void request() { System.out.println(&quot;do Machine&quot;); } } 单例模式定义：确保类只有一个实例，并提供一个全局访问点 主类 12345678910111213141516171819202122package fans.hitagi.singlleton; /** * 引入设计原则：无 * 使用设计模式：单例模式 * 通过私有化构造方法，来达到仅有一个实例的方式 * 多线程需要其他处理方法 */ public class Singleton { private static Singleton uniqueInstance; private Singleton(){ } public static Singleton getInstance90(){ if(uniqueInstance == null){ uniqueInstance = new Singleton(); } return uniqueInstance; } } 迭代器模式定义： 主类 1234567891011121314151617181920212223242526272829303132package fans.hitagi.dinner; /** * 引入设计原则：9 * 使用设计模式：迭代器模式 * 通过实现迭代器接口，类中集合类型对象的访问被封装于类中，保证访问的统一 */ public class DinerMenuIterator implements Iteator{ MenuItem[] items; int position = 0; public DinerMenuIterator(MenuItem[] items){ this.items = items; } @Override public boolean hasNext() { if(position &gt;= this.items.length || items[position] == null){ return false; }else { return true; } } @Override public Object next() { MenuItem menuItem = items[position]; position += 1; return menuItem; } } 迭代器接口 123456789package fans.hitagi.dinner; /** * 迭代器接口 */ public interface Iteator{ boolean hasNext(); Object next(); } 元素类 1234567package fans.hitagi.dinner; /** * 元素类 */ public class MenuItem { } 工厂模式定义： 工厂：定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类中 抽象工厂：提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类 工厂抽象类 1234567891011121314151617package fans.hitagi.pizza; /** * 引入设计原则：6 * 使用设计模式：抽象工厂 * 工厂抽象类，定义了一系列产品族的抽象方法 * 子类只需要根据具体情况返回产品族的具体实现 * 普通类-&gt;简单工厂：提供了一个自动生产对象的工厂 * 简单工厂-&gt;工厂方法：将工厂抽象，不同工厂有不同实现 * 工厂方法-&gt;抽象工厂：将产品定义为产品组，抽象工厂指定产品族，实际工厂具体实现产品组的实例类 */ public interface PizzaIngredientFectory { Dough createDough(); Sauce createSauce(); Cheese createCheese(); Clams createClams(); } 产品家族抽象类 12345678910111213package fans.hitagi.pizza; public interface Cheese { }public interface Clams { }public interface Dough { }public interface Sauce { } 产品家族具体实现 12345678910111213141516171819202122package fans.hitagi.pizza; public class FreshClams implements Clams { }public class FrozenClams implements Clams{ }public class MarinaraSouce implements Sauce{ }public class PlumTomatoSauce implements Sauce{ }public class MozzarellaCheese implements Cheese{ }public class ReggianoCheese implements Cheese{ }public class ThickcrusDough implements Dough{ }public class TinCrustDough implements Dough{ } 工厂具体实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445package fans.hitagi.pizza; public class NYPizzaIngredientFactory implements PizzaIngredientFectory{ @Override public Dough createDough() { return new ThickcrusDough(); } @Override public Sauce createSauce() { return new PlumTomatoSauce(); } @Override public Cheese createCheese() { return new MozzarellaCheese(); } @Override public Clams createClams() { return new FrozenClams(); } }public class ChicagoPizzaIngredientFactory implements PizzaIngredientFectory{ @Override public Dough createDough() { return new TinCrustDough(); } @Override public Sauce createSauce() { return new MarinaraSouce(); } @Override public Cheese createCheese() { return new ReggianoCheese(); } @Override public Clams createClams() { return new FreshClams(); } } 观察者模式定义：定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，他的所有依赖着都会收到通知并自动更新 主类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package fans.hitagi.weather; import java.util.ArrayList; /** * 引入设计原则：4 * 使用设计模式：观察者模式 * 通过接口抽象了观察者的两个行为和主题的行为 */ public class WeatherDate implements Subject{ private ArrayList&lt;Observer&gt; observers; private float temperature; private float humidity; private float pressure; public WeatherDate() { this.observers = new ArrayList&lt;Observer&gt;(); } @Override public void reigisterObserver(Observer observer) { observers.add(observer); } @Override public void removeObserver(Observer observer) { int i = observers.indexOf(observer); if (i &gt;= 0){ observers.remove(i); } } @Override public void notifyObserver() { for (Observer observer:observers) { observer.update(temperature,humidity,pressure); } } public void measurementsChanged(){ notifyObserver(); } public void setMeasurements(float temperature,float humidity,float pressure){ this.temperature = temperature; this.humidity = humidity; this.pressure = pressure; notifyObserver(); } } 观察者类 1234567891011121314151617181920212223242526272829package fans.hitagi.weather; /** * 通过实现两个行为来进行数据修改和展示 */ public class CurrentConditionsDisplay implements Observer,DisplayElemeent{ private float temperature; private float humidity; private Subject weatherData; public CurrentConditionsDisplay(Subject weatherData) { this.weatherData = weatherData; weatherData.reigisterObserver(this); } @Override public void display() { System.out.println(&quot;temperature: &quot;+ temperature + &quot; humidity&quot; + humidity); } @Override public void update(float temperature, float humidity, float pressure) { this.temperature = temperature; this.humidity = humidity; display(); } } 行为接口 123456789101112131415161718192021222324252627package fans.hitagi.weather; /** * 观察者实现该行为 * 观察者在被主题调用修改行为后自动调用该行为 * 通过该行为来进行数据的展示 */ public interface DisplayElemeent { void display(); }/** * 观察者实现该行为 * 主题通过调用该行为来通知观察者数据的改变 */ public interface Observer { void update(float temperature,float humidity,float pressure); }/** * 主题通过该行为注册删除观察者 * 观察者调用主题的行为来进行注册 * 主题改变后调用通知行为通知观察者 */ public interface Subject { void reigisterObserver(Observer observer); void removeObserver(Observer observer); void notifyObserver(); } 命令模式定义：将请求封装成对象，以便使用不同的请求，队列或操作日志来参数化其他对象。命令模式也可以在支持撤销的操作。 控制类 12345678910111213141516171819202122package fans.hitagi.control; /** * 引入设计原则；无 * 使用设计模式：命令模式 * 主类绑定并使用命令对象，使得命令方式统一，便于管理 */ public class RemoteControl { Command[] commands; public RemoteControl() { this.commands = new Command[2]; } public void setCommands(int slot,Command command){ this.commands[slot] = command; } public void doCommand(int slot){ this.commands[slot].excute(); } } 命令抽象接口 12345678package fans.hitagi.control; /** * 命令封装接口，所有命令都是用excute执行，具体逻辑具体类来实现 */ public interface Command { void excute(); } 模板方法定义：在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤 模板抽象类 123456789101112131415161718192021222324252627282930313233343536package fans.hitagi.tea; /** * 引入设计原则：8 * 使用设计模式：模板方法 * 模板抽象类的抽象方法通过将方法的调用顺序固定，而方法则将需要的延迟到子类 * 通过一个方法的返回值来确定另一个方法的调用，而这个返回值则根据具体实现来决定，以此构建了一个钩子 * 非抽象方法子类选择重写，抽象方法子类必须重写 */ public abstract class Caffeinebeverage { final void prepareRecipe(){ bioWate(); brew(); pouInCup(); if(customerwantsCondiments()){ addCondiments(); } } abstract void brew(); abstract void addCondiments(); void pouInCup(){ } void bioWate(){ } boolean customerwantsCondiments(){ return true; } } 实现类 1234567891011121314151617181920212223242526/** * 实现类 */ public class Caffee extends Caffeinebeverage{ @Override void brew() { } @Override void addCondiments() { } }public class Tea extends Caffeinebeverage{ @Override void brew() { } @Override void addCondiments() { } } 适配器模式定义；将一个类的接口，转换成客户端的另一个接口。适配器让原本的接口不兼容的类可以合作无间 适配器类 1234567891011121314151617181920212223242526package fans.hitagi.durkey; /** * 引入设计原则：无 * 使用设计模式：适配器模式--对象适配器(类适配器需要多重继承) * 通过继承需要适配的类，然后再在类中引用一个需要被适配的对象，这样就可以访问适配类的时候自动访问被适配类的方法 */ public class DurkeyAdapter extends Duck{ Durkey durkey; public DurkeyAdapter(Durkey durkey) { this.durkey = durkey; } @Override void quack() { this.durkey.gobble(); } @Override void fly() { this.durkey.fly(); } } 适配与被适配类 1234567891011121314151617package fans.hitagi.durkey; /** * 适配类 */ public abstract class Duck { abstract void quack(); abstract void fly(); }/** * 被适配类 */ public abstract class Durkey { abstract void gobble(); abstract void fly(); } 外观模式定义：定义了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层结构，让子系统更容易使用。 控制类 123456789101112131415161718192021222324package fans.hitagi.tv; /** * 引入设计原则：7 * 使用设计模式：外观模式 * 通过使用外观对象来对复杂的系统类进行调用，客户仅需访问外观对象的固定方法即可 * 类似于命令模式，都是封装统一 */ public class TVControl implements Facde{ Channel channel; Volume volume; public TVControl(Channel channel, Volume volume) { this.channel = channel; this.volume = volume; } @Override public void toDo() { channel.setValue(10); volume.setRange(10); } } 控制抽象接口 12345678package fans.hitagi.tv; /** * 控制类抽象接口 */ public interface Facde { void toDo(); } 子系统类 12345678910111213141516171819202122232425262728293031package fans.hitagi.tv; /** * 子系统类 */ public class Channel { int value = 0; public int getValue() { return value; } public void setValue(int value) { this.value = value; } }/** * 子系统类 */ public class Volume { int range = 0; public int getRange() { return range; } public void setRange(int range) { this.range = range; } } 装饰模式定义：动态的将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的方案 核心类 12345678910111213141516/** * 引入设计原则：5 * 使用设计模式：装饰者模式 * 核心类，保证了每次装饰其本质不变(父类型指向子对象) * 通过将饮料分为材料和基础饮料和添加材料两种子类，划分了其逻辑功能。 * java的IO流正是使用了这种设计模式 */ public abstract class Beverage { public String description = &quot;Unknown Beverage &quot;; public String getDescription(){ return this.description; } public abstract double cost(); } 材料抽象类 12345678910package fans.hitagi.coffee; /** * 材料抽象类，保证了材料都必须继承获取描述的动作 * 由其封装饮料类，但本质也是饮料。 * 保证了即使拓展也不需要修改类 */ public abstract class CondimentDecorator extends Beverage{ public abstract String getDescription(); } 材料实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package fans.hitagi.coffee; /** * 牛奶类 */ public class Milk extends CondimentDecorator{ Beverage beverage; public Milk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .20+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;， Milk&quot;; } }/** * 摩卡类 */ public class Mocha extends CondimentDecorator{ Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .18+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;, Mocha&quot;; } } 基础饮品类 12345678910111213141516171819202122232425262728293031323334package fans.hitagi.coffee; /** * 饮料类 */ public class HouseBlend extends Beverage{ public HouseBlend() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } }package fans.hitagi.coffee; /** * 饮料类 */ public class Espresso extends Beverage{ public Espresso() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } } 状态模式定义：动态的将责任附加到对象上。若要拓展功能，装饰者提供了比继承更有弹性的方案 核心类 12345678910111213141516/** * 引入设计原则：5 * 使用设计模式：装饰者模式 * 核心类，保证了每次装饰其本质不变(父类型指向子对象) * 通过将饮料分为材料和基础饮料和添加材料两种子类，划分了其逻辑功能。 * java的IO流正是使用了这种设计模式 */ public abstract class Beverage { public String description = &quot;Unknown Beverage &quot;; public String getDescription(){ return this.description; } public abstract double cost(); } 材料抽象类 12345678910package fans.hitagi.coffee; /** * 材料抽象类，保证了材料都必须继承获取描述的动作 * 由其封装饮料类，但本质也是饮料。 * 保证了即使拓展也不需要修改类 */ public abstract class CondimentDecorator extends Beverage{ public abstract String getDescription(); } 材料实现类 1234567891011121314151617181920212223242526272829303132333435363738394041424344package fans.hitagi.coffee; /** * 牛奶类 */ public class Milk extends CondimentDecorator{ Beverage beverage; public Milk(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .20+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;， Milk&quot;; } }/** * 摩卡类 */ public class Mocha extends CondimentDecorator{ Beverage beverage; public Mocha(Beverage beverage) { this.beverage = beverage; } @Override public double cost() { return .18+beverage.cost(); } @Override public String getDescription() { return beverage.getDescription() + &quot;, Mocha&quot;; } } 基础饮品类 12345678910111213141516171819202122232425262728293031323334package fans.hitagi.coffee; /** * 饮料类 */ public class HouseBlend extends Beverage{ public HouseBlend() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } }package fans.hitagi.coffee; /** * 饮料类 */ public class Espresso extends Beverage{ public Espresso() { this.description = &quot;Espresso&quot;; } @Override public double cost() { return 1.99; } } 组合模式定义：允许你将对象组合成树形结构来表现整体/部分的层次结构。组合能让客户以一致的方式处理个别对象一级对象组合 菜单抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142package fans.hitagi.menu; /** * 引入设计原则：无 * 使用设计模式：组合模式 * 抽象了菜单，将所有可能实现的方法进行异常抛出，防止使用未被重写的方法 * 统一了菜单和组合菜单---多态 */ public abstract class MenuComponent { public void add(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } public void remove(MenuComponent menuComponent){ throw new UnsupportedOperationException(); } public MenuComponent getChild(int i){ throw new UnsupportedOperationException(); } public String getName(){ throw new UnsupportedOperationException(); } public String getDescription(){ throw new UnsupportedOperationException(); } public double getPrice(){ throw new UnsupportedOperationException(); } public boolean isVegetarian(){ throw new UnsupportedOperationException(); } public void print(){ throw new UnsupportedOperationException(); } } 普通菜单类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package fans.hitagi.menu; /** * 普通菜单，仅仅只能添加材料 */ public class menuiItem extends MenuComponent{ String name; String description; boolean vegetarian; double price; public menuiItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } @Override public String getName() { return name; } @Override public String getDescription() { return description; } @Override public boolean isVegetarian() { return vegetarian; } @Override public double getPrice() { return price; } public void print(){ System.out.println(&quot; &quot; + getName()); if(isVegetarian()){ System.out.println(&quot;(v)&quot;); } System.out.println(&quot;, &quot; + getPrice()); System.out.println(&quot; ----&quot; + getDescription()); } } 组合菜单类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package fans.hitagi.menu; import fans.hitagi.dinner.Iteator; import java.util.ArrayList; /** * 组合菜单 * 可以添加普通菜单和材料 * 和菜单同样被视为菜单的抽象 * 多实现了添加和删除方法 * print方法的不同区分了两种菜单在输出的时候的不同处理方式，但又都是菜单的抽象，方法相同，因此向访问者的访问方式进行了统一 * print方法使用了递归的方式，知道成为普通菜单位置，自顶向下的逐个访问 */ public class menu extends MenuComponent{ ArrayList menus = new ArrayList(); String name; String descritption; public menu(String name, String descritption) { this.name = name; this.descritption = descritption; } @Override public void add(MenuComponent menuComponent) { super.add(menuComponent); } @Override public void remove(MenuComponent menuComponent) { super.remove(menuComponent); } @Override public MenuComponent getChild(int i) { return super.getChild(i); } @Override public String getName() { return this.name; } @Override public String getDescription() { return this.descritption; } public void print(){ System.out.println(&quot;\\n&quot; + getName()); System.out.println(&quot;, &quot; + getDescription()); System.out.println(&quot;----------------------&quot;); Iteator iteator = (Iteator) menus.iterator(); while (iteator.hasNext()){ MenuComponent next = (MenuComponent) iteator.next(); next.print(); } } }","link":"/2022/08/10/DesignPatterns/"},{"title":"js基础知识","text":"小技巧 prettier插件：下载后前往 default formatter 配置（最好开启 format on save），通过.prettier进行配置todo Hightlight高亮某些部分（需要以json格式打开setting配置）安装node.js live-server（win11 禁止脚本）谷歌debug可以尝试使用可以使用console.table()来展示对象信息``` 详情 1. 基础知识七大基本类型（通过typeof进行配型判断） number：数字string：字符串undefined：未定义null：无值（用控制台打印出是 object）boolean：布尔值object：对象symbol：独一无二值 三大变量创建方法 var：老式–函数作用域let：新式–块作用域const：不改变的值–块作用域 可以使用js的严格模式，帮助自动调整格式，且更详细的检查错误 1'use strict'; 函数有三种声明方式（可以互相调用） 1234567function a(x){ return x;}//声明方式，可以先使用在声明const b = function(x){ return x;}//表达式方式，只能先声明，但是函数及模板等地方可以使用const c = x =&gt; x//简化写法 数组建立有两个方式（使用 [] 访问） 不同于java，数组可以动态的改变长度（即声明长度为x，设置长度可以大于x） 12const a = [1,2];const b = new Array(1,2); 常见方法 1234567push() //添加最后一个pop() //删除最后一个shift() //删除第一个indexOf() //获取某个元素的位置includes() //是否存在某个元素concat()//合并数组Max()//获取数组最大值 对象创建方式（属性可以用 . 也可以用 [“string”] 的方式访问，后者可以使用拼接） 123456const jam = { name:'jam', a:function(){ return 1; }} Math的方法 12Math.random()//获取随机数Math.trunc()//取整 2. js引擎三大范式：面向过程，函数式，面向对象 非阻塞模型：可以异步或者多线程执行 现在基本上没有语言是纯解释或者纯编译了 jsweb由三部分组成，js引擎（堆栈）；webapis；回调函数。正式因为如此，js可以脱离浏览器运行，之所以能在浏览器上运行，仅仅是因为其调用了webapi js运行时， 首先创建执行上下文（存储了基本信息，一个代码运行环境），如全局变量声明，函数表达式，其中，函数中的代码则需要调用时才会执行 然后执行顶层代码（第一个代码） 然后是函数执行，等待回调函数 执行上下文内部（因此这些都是在执行前就产生的）： 可变环境：存储了声明的变量，函数（函数会在执行的时候获取自己的环境参数）（箭头函数不会获取参数对象（传参）和this关键字） 作用域链 this关键字 执行上下文会被放在栈的底部 词法作用域：控制变量的访问范围（变量会链式查找—如同一个继承链）（java不能调用方法外部，且非传参的参数） 全局作用域：顶层代码 块作用域：大括号中声明的变量（ES6才有，仅仅适用于const和let） 函数作用域：函数内部声明的变量 声明之所以上移，是因为在运行之前，形成执行上下文的时候就已经声明成功了（因此函数声明可以放在后面，而表达式不行）var的声明被上移了！。var在定义前调用会未初始化，其他二者直接报错。var没有块作用域概念出现时间 函数声明&gt;var&gt;const/let（表达式可以用var也可用const，let） 引入时间死区更有利于排错，放置一些奇怪的bug 这些奇怪的性质都是因为js创建之初从未想过会有如此广泛的应用，为了保证向后兼容，这些性质不会被删除，只能尽量使用let或者const来避免 this关键字（this指自身函数外部一层的对象，而箭头函数没有this，因此这里的自身是指的外部那一层的自身）–用函数中this访问对象时一定要注意，函数究竟在哪个位置，是否在对象中！ 1234方法：对象简单函数：未定义（严格模式），windows对象箭头函数：外围的(函数)this（自身没有）事件监听者：dom对象 可以设置self=this（多层嵌套时，同样可以使用箭头函数取外围函数的this） arguments关键字，获取参数表 存储方式：对象存储地址，普通类型则存储值","link":"/2022/08/24/js%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"python简单记录","text":"print可以打印输出，字符串中特殊符号或者操作需要运用转义字符 python中格式的缩进十分重要 python通过input进行输入 详情 python中是通过len()函数来获得字符串长度，而并非同java，js那样的length属性 python声明变量不需要关键字 同c语言，python可以将字符串当成数组进行输出 同样是通过+拼接字符串 通过type()函数获取类型 可以f”” 或者””.format()方式格式化字符串 取余% 整除// 使用random的方法进行随机数创造（可以直接指定范围，而不是生成一个0-1的小数），也可以使用传统的生成器random.random() python用import 导入模组 python以split分割字符串 python的foreach实现为for item in items python通过max()函数获取最大值 使用for number in range(a,b,c)来创造普通循环 def name(): 的形式来创建函数 while函数与其他语言一样 字符串的比较：is 比较的是id == 比较的是value ‘’‘类似于js中的~，可以自动换行 函数定义时可以使用 = 的形式来给予参数默认值 ord获取ascii码值，chr获取对应str值 python中字典{}声明即是key-value的组合，同el表达式，可以直接通过[]的方式获取，遍历获取的是key，嵌套则多个[]即可 作用域：python全局作用域不同于其他语言，js可以在函数内部访问修改全局变量，python必须通过global关键字才能进行修改，否则会出现一个同名但完全不同的变量。对于java，因为Java并不是函数式语言，其全局变量仅仅能够直接作用于该类的方法中。且python并没有块作用域。（函数内部并不算是块作用域） global关键字可以使用修改全局变量，但请在修改时慎重考虑 pycharm可以查看历史记录，可以帮助修改样式，帮助查看项目结构 模块.变量名 可以获取模块的对应变量 可以在pypi网站获取其他开发者的包或者查看他们的的源代码 命名方式参照java 通过pass关键字可以代替空格，且不报错 python对象可以动态添加属性 _ _ init _ _ 函数在对象初始化阶段运行，可以设置参数（传参或者默认值） self指向自己 元组是不可变序列 random.choise可以选择数组中元素 函数加了括号就代表运行该函数 python通常是在___init___方法中初始化参数的，python并不能直接写出参数 继承之后一定要调用sper()._ _ init _ _ 方法 列表可以切片 [star:end:step]这和range函数类似 当出现多个同样类时,可以设计一个管理类来管理他们 open函数打开文件，read读取，write写入，close关闭，mode指定打开方式，用with语句可以不用关闭 使用pandas来进行数据分析 列表可以通过 n + 1 for n in numbers if test 实现 字典可以通过 new_key : new_value for (key,value) in dict","link":"/2022/08/24/python%E7%AE%80%E5%8D%95%E8%AE%B0%E5%BD%95/"},{"title":"mysql简单操作","text":"详情 查询语句1. 基础查询这是基础查询的完整命令 123456789101112131415SELECT //需要列出的字段 users.uname FROM //需要查询的列表 users WHERE //初次筛选条件（不能使用聚合函数） uid = &quot;1&quot;GROUP BY //分组 uid HAVING //分组后筛选条件（可以使用聚合函数） uid IS NOT NULL ORDER BY //排序条件 uidDESC //排序方式为降序LIMIT //取前几个数据 1 2. 连接查询取笛卡尔积 123456SELECT *from students,classesWHERE students.cid = classes.cid 自然连接（自动匹配连接字段，但字段名要相同） 12345SELECT * FROM students NATURAL JOIN classes 内连接（仅显示符合条件） 123456SELECT * FROM students INNER JOIN classes ON cid 外连接（外连接方向符合条件即可） 123456SELECT * FROM students RIGHT JOIN JOIN classes ON cid 列表操作1. 列表的更新创建语句 123456create table teachers( `tid` varchar(100) not null COMMENT &quot;教师id&quot;, `tname` varchar(100) unique not null COMMENT &quot;教师姓名&quot;, `cid` int(100) UNSIGNED not null COMMENT &quot;课程id&quot;, primary key(tid)) 更改语句 1ALTER TABLE teachers ADD phone_number VARCHAR ( 200 ) DEFAULT &quot;11111111111&quot; COMMENT &quot;电话号码&quot; 删除语句 1drop table teachers 2. 数据的更新插入数据 1234insert into teachers(tid,tname,cid,phone_number)values(&quot;1&quot;,&quot;张三&quot;,10,&quot;15220398751&quot;),(&quot;2&quot;,&quot;李四&quot;,13,&quot;12648975368&quot;) 删除数据 12delete from teacherswhere tid = &quot;1&quot; 更新数据 123update teachersset tname = &quot;王五&quot;where tid = &quot;2&quot; 视图操作1. 创建视图123create view myview asselect * from teachers 2. 查看视图12select * from myview 3. 删除视图1drop view myview","link":"/2022/08/18/mysql%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"}],"tags":[{"name":"设计模式笔记","slug":"设计模式笔记","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%AC%94%E8%AE%B0/"}],"categories":[],"pages":[{"title":"about","text":"","link":"/about/index.html"}]}